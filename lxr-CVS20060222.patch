diff -urN -x CVS -x .cvsignore lxr-0.9.4/INSTALL lxr/INSTALL
--- lxr-0.9.4/INSTALL	2005-01-05 18:13:20.000000000 +0100
+++ lxr/INSTALL	2005-11-03 00:39:55.000000000 +0100
@@ -26,6 +26,10 @@
 
 7) If using the CVS support, you will need rcs installed as well.
 
+8) If you are using the BitKeeper support, you will need:
+	BitKeeper (bk) installed
+	Digest::SHA module (available from CPAN)
+
 Installing the database
 -----------------------
 You will need to create a database for lxr, and possibly create a user
diff -urN -x CVS -x .cvsignore lxr-0.9.4/diff lxr/diff
--- lxr-0.9.4/diff	2004-10-26 19:08:07.000000000 +0200
+++ lxr/diff	2005-11-03 00:39:55.000000000 +0100
@@ -1,5 +1,5 @@
 #!/usr/bin/perl -T
-# $Id$
+# $Id$
 
 # diff --	Display diff output with markup.
 #
@@ -23,7 +23,7 @@
 
 ######################################################################
 
-$CVSID = '$Id$ ';
+$CVSID = '$Id$ ';
 
 use strict;
 use lib '.'; # for Local.pm
@@ -31,6 +31,7 @@
 
 use LXR::Common qw(:html);
 use Local;
+use FileHandle;
 
 sub htmlsub {
 	my ($s, $l) = @_;
diff -urN -x CVS -x .cvsignore lxr-0.9.4/fixhashbang lxr/fixhashbang
--- lxr-0.9.4/fixhashbang	1999-09-22 12:32:49.000000000 +0200
+++ lxr/fixhashbang	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
-#!/bin/sh
-
-if [ -z "$1" ]; then
-    echo First argument must be path of desired Perl interpreter.
-    exit 0;
-fi
-
-for f in `ls -ld ./* | grep '^-..x' | cut -d/ -f2`; do
-    sed -e "1s,^#!.*perl.*,#!$1," < $f > $f.new
-    cp $f.new $f
-    rm $f.new
-done
diff -urN -x CVS -x .cvsignore lxr-0.9.4/genjavaclasses lxr/genjavaclasses
--- lxr-0.9.4/genjavaclasses	1999-04-09 12:18:01.000000000 +0200
+++ lxr/genjavaclasses	1970-01-01 01:00:00.000000000 +0100
@@ -1,70 +0,0 @@
-#!/usr/bin/perl
-#
-# added by jmason to support identifying references to java system classes in
-# LXR-cross-referenced .java files.
-#
-# This only needs to be run when a new version of the Java system class set is
-# released. The bundled JavaClassList.pm should do the trick nicely.
-# 
-# This tool requires that the Info-Zip tool 'zipinfo' is installed in the PATH.
-
-use lib 'lib/';
-
-if (!defined ($ARGV[0])) {
-    die "usage: genjavaclasses { java_classes.zip | java_classes.jar }\n";
-}
-
-$classes_zip = $ARGV[0];
-open (ZIPINFO, "zipinfo $classes_zip |")
-			 || die "cannot run 'zipinfo $classes_zip'\n";
-
-$outfile = $INC[0]."/JavaClassList.pm";
-open (OUT, "> $outfile.new") || die "cannot write to '$outfile.new'\n";
-
-print OUT '# [Generated by genjavaclasses at '.localtime().']
-
-    package JavaClassList;
-    require Exporter;
-    @ISA = qw(Exporter);
-    @EXPORT = qw(&is_java_class);
-
-    sub is_java_class {
-	local ($name, @imported_packages) = @_;
-	local ($_);
-
-        if (!defined %java_system_classes) {
-          foreach $_ (@java_system_classes) { $java_system_classes{$_} = 1; }
-        }
-
-        if (defined ($java_system_classes{$name})) { return 1; }
-
-	foreach $_ (@imported_packages) {
-	    if (defined ($java_system_classes{$_.$name})) { return 1; }
-	}
-	0;
-    }
-
-    @java_system_classes = qw(
-    	# AUTOMATICALLY GENERATED LIST STARTS HERE
-';
-
-while (<ZIPINFO>) {
-    / (\S+)\.class\s*$/ || next;
-    $_ = $1; s,/,.,g; print OUT "\t$_\n";
-}
-close ZIPINFO || die "'zipinfo $classes_zip' failed\n";
-
-print OUT '
-    	# AUTOMATICALLY GENERATED LIST ENDS HERE
-    );
-
-    1;
-';
-
-if (-r $outfile) {
-    rename ($outfile, "$outfile.bak") || die "rename of $outfile failed\n";
-}
-rename ("$outfile.new", $outfile) || die "rename to $outfile failed\n";
-exit;
-
-# vim:sw=4:
diff -urN -x CVS -x .cvsignore lxr-0.9.4/genxref lxr/genxref
--- lxr-0.9.4/genxref	2004-07-21 22:44:30.000000000 +0200
+++ lxr/genxref	2005-11-03 00:39:55.000000000 +0100
@@ -51,6 +51,7 @@
   --version=VERSION  Generate tokens for the given version of the code.
   --allversions      Generate tokens for all versions of the code (default).
   --reindexall       Purges existing index data
+  
 Report bugs at http://sourceforge.net/projects/lxr/.
 END_HELP
 	exit 0;
@@ -67,7 +68,7 @@
 
 die("No matching configuration") unless $config->sourceroot;
 
-$files = new LXR::Files($config->sourceroot);
+$files = new LXR::Files($config->sourceroot, $config->sourceparams);
 die "Can't create file access object " . $config->sourceroot
   if !defined($files);
 $index = new LXR::Index($config->dbname, O_RDWR | O_CREAT);
diff -urN -x CVS -x .cvsignore lxr-0.9.4/lib/LXR/Common.pm lxr/lib/LXR/Common.pm
--- lxr-0.9.4/lib/LXR/Common.pm	2005-05-05 01:19:33.000000000 +0200
+++ lxr/lib/LXR/Common.pm	2005-11-03 00:39:55.000000000 +0100
@@ -1,6 +1,6 @@
 # -*- tab-width: 4 -*- ###############################################
 #
-# $Id$
+# $Id$
 #
 # FIXME: java doesn't support super() or super.x
 
@@ -20,7 +20,7 @@
 
 package LXR::Common;
 
-$CVSID = '$Id$ ';
+$CVSID = '$Id$ ';
 
 use strict;
 
@@ -169,7 +169,6 @@
 		return (undef);
 	}
 
-	$t =~ s/\+/ /g;
 	$t =~ s/\%([\da-f][\da-f])/pack("C", hex($1))/gie;
 
 	return ($t);
@@ -494,7 +493,7 @@
 	
 	$config     = new LXR::Config($HTTP->{'this_url'});
 	die "Can't find config for " . $HTTP->{'this_url'} if !defined($config);
-	$files = new LXR::Files($config->sourceroot);
+	$files = new LXR::Files($config->sourceroot, $config->sourceparams);
 	die "Can't create Files for " . $config->sourceroot if !defined($files);
 	$index = new LXR::Index($config->dbname);
 	die "Can't create Index for " . $config->dbname if !defined($index);
@@ -539,10 +538,10 @@
 	
 	if(defined $path) {
 		# First suppress anything after a dodgy character
-		$path =~ s!(^[\w_+-,.%^/]+).*!$1!;
+		$path =~ s!(^[\w_+\-,.%^/\!]+).*!$1!;
 		# Clean out /../
-		while ($path =~ m!/../!) {
-			$path = s!/\.\./!/!g;
+		while ($path =~ m!/\.\.?/!) {
+			$path =~ s!/\.\.?/!/!g;
 		}
 	}
 	
diff -urN -x CVS -x .cvsignore lxr-0.9.4/lib/LXR/Config.pm lxr/lib/LXR/Config.pm
--- lxr-0.9.4/lib/LXR/Config.pm	2004-07-21 22:44:30.000000000 +0200
+++ lxr/lib/LXR/Config.pm	2005-09-10 02:09:20.000000000 +0200
@@ -1,6 +1,6 @@
 # -*- tab-width: 4 -*- ###############################################
 #
-# $Id$
+# $Id$
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -18,7 +18,7 @@
 
 package LXR::Config;
 
-$CVSID = '$Id$ ';
+$CVSID = '$Id$ ';
 
 use strict;
 
@@ -106,8 +106,16 @@
 			}
 		}
 	}
-
-	die "Can't find config for $url\n" if !defined $$self{baseurl};
+	
+	if(!defined $$self{baseurl}) {
+		if($url =~ m!http://.+\.!) {
+			die "Can't find config for $url: make sure there is a 'baseurl' line that matches in lxr.conf\n";
+		} else {	
+			# wasn't a url, so probably genxref with a bad --url parameter
+			die "Can't find config for $url: " . 
+			 	"the --url parameter should be a URL (e.g. http://example.com/lxr) and must match a baseurl line in lxr.conf\n";
+		}
+	}
 }
 
 sub allvariables {
diff -urN -x CVS -x .cvsignore lxr-0.9.4/lib/LXR/Files/BK.pm lxr/lib/LXR/Files/BK.pm
--- lxr-0.9.4/lib/LXR/Files/BK.pm	1970-01-01 01:00:00.000000000 +0100
+++ lxr/lib/LXR/Files/BK.pm	2005-11-03 00:39:55.000000000 +0100
@@ -0,0 +1,305 @@
+# -*- tab-width: 4 -*- ###############################################
+#
+# $Id$
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+package LXR::Files::BK;
+
+$CVSID = '$Id$ ';
+
+use strict;
+use File::Spec;
+use Cwd;
+use IO::File;
+use Digest::SHA qw(sha1_hex);
+use Time::Local;
+use LXR::Common;
+
+use vars qw(%tree_cache @ISA $memcachecount $diskcachecount);
+
+@ISA = ("LXR::Files");
+$memcachecount = 0;
+$diskcachecount = 0;
+
+sub new {
+	my ($self, $rootpath, $params) = @_;
+
+	$self = bless({}, $self);
+	$self->{'rootpath'} = $rootpath;
+	$self->{'rootpath'} =~ s!/*$!!;
+	die "Must specify a cache directory when using BitKeeper" if !(ref($params) eq 'HASH');
+	$self->{'cache'} = $$params{'cachepath'};
+	return $self;
+}
+
+#
+# Public interface
+#
+
+sub getdir {
+	my ($self, $pathname, $release) = @_;
+
+	$self->fill_cache($release);
+	$pathname = canonise($pathname);
+	$pathname = File::Spec->rootdir() if $pathname eq '';
+	my @nodes = keys %{ $tree_cache{$release}->{$pathname} };
+	my @dirs = grep m!/$!, @nodes;
+	my @files = grep !m!/$!, @nodes;
+	return (sort(@dirs), sort(@files));
+}
+
+sub getfile {
+	my ($self, $pathname, $release) = @_;
+	$pathname = canonise($pathname);
+	my $fileh = $self->getfilehandle($pathname, $release);
+
+	return undef unless $fileh;
+	my $buffer = join('', $fileh->getlines);
+	close $fileh;
+	return $buffer;
+}
+
+sub getfilehandle {
+	my ($self, $pathname, $release) = @_;
+	$pathname = canonise($pathname);
+	my $fileh = undef;
+	if ($self->file_exists($pathname, $release)) {
+		my $info  = $self->getfileinfo($pathname, $release);
+		my $ver   = $info->{'revision'};
+		my $where = $info->{'curpath'};
+		$fileh = $self->openbkcommand("bk get -p -r$ver $where 2>/dev/null |");
+	}
+	return $fileh;
+}
+
+sub filerev {
+	my ($self, $filename, $release) = @_;
+
+	my $info = $self->getfileinfo($filename, $release);
+	return sha1_hex($info->{'curpath'} . '-' . $info->{'revision'});
+}
+
+sub getfiletime {
+	my ($self, $pathname, $release) = @_;
+
+	my $info = $self->getfileinfo($pathname, $release);
+	return undef if !defined $info;
+
+	if (!defined($info->{'filetime'})) {
+		my $fileh = $self->openbkcommand("bk prs -r$info->{'revision'} -h -d:UTC: $info->{'curpath'} |");
+		my $time = <$fileh>;    # Should be a YYYYMMDDHHMMSS string
+		close $fileh;
+		chomp $time;
+		my ($yr, $mth, $day, $hr, $min, $sec) =
+		  $time =~ m/(....)(..)(..)(..)(..)(..)/;
+		$info->{'filetime'} = timegm($sec, $min, $hr, $day, $mth-1, $yr);
+	}
+
+	return $info->{'filetime'};
+}
+
+sub getfilesize {
+	my ($self, $pathname, $release) = @_;
+
+	my $info = $self->getfileinfo($pathname, $release);
+	return undef if !defined($info);
+
+	if (!defined($info->{'filesize'})) {
+		$info->{'filesize'} = length($self->getfile($pathname, $release));
+	}
+	return $info->{'filesize'};
+}
+
+
+sub getauthor {
+	my ($self, $pathname, $release) = @_;
+
+	my $info = $self->getfileinfo($pathname, $release);
+	return undef if !defined $info;
+
+	if (!defined($info->{'author'})) {
+		my $fileh = $self->openbkcommand("bk prs -r$info->{'revision'} -h -d:USER: $info->{'curpath'} |");
+		my $user = <$fileh>;
+		close $fileh;
+		chomp $user;
+		$info->{'author'} = $user;
+	}
+
+	return $info->{'author'};
+}
+
+sub getannotations {
+	# No idea what this function should return - Plain.pm returns (), so do that
+	return ();
+}
+
+sub openbkcommand {
+	my ($self, $command) = @_;
+
+	my $dir = getcwd();	
+	chdir($self->{'rootpath'});
+	my $fileh = new IO::File;
+	$fileh->open($command) or die "Can't execute $command";
+	chdir($dir);
+	return $fileh;
+}
+
+sub isdir {
+	my ($self, $pathname, $release) = @_;
+	$self->fill_cache($release);
+	$pathname = canonise($pathname);
+	my $info = $tree_cache{$release}{$pathname};
+	return (defined($info));
+}
+
+sub isfile {
+	my ($self, $pathname, $release) = @_;
+	my $info = $self->getfileinfo($pathname, $release);
+	return (defined($info));
+}
+
+sub tmpfile {
+	my ($self, $filename, $release) = @_;
+	my ($tmp,  $buf);
+
+	$buf = $self->getfile($filename, $release);
+	return undef unless defined($buf);
+
+	$tmp =
+	    $config->tmpdir
+	  . '/bktmp.'
+	  . time . '.'
+	  . $$ . '.'
+	  . &LXR::Common::tmpcounter;
+	open(TMP, "> $tmp") || return undef;
+	print(TMP $buf);
+	close(TMP);
+
+	return $tmp;
+}
+
+#
+# Private interface
+#
+
+sub insert_entry {
+	my ($newtree, $path, $entry, $curfile, $rev) = @_;
+	$$newtree{$path} = {} if !defined($$newtree{$path});
+	$newtree->{$path}{$entry} = { 'curpath' => $curfile, 'revision' => $rev };
+}
+
+sub fill_cache {
+	my ($self, $release) = @_;
+
+	return if (defined $tree_cache{$release});
+
+	# Not in cache, so need to build
+	my @all_entries = $self->get_tree($release);
+	$memcachecount++;
+
+	my %newtree = ();
+	my ($entry, $path, $file, $vol, @dirs);
+	my ($curfile, $histfile, $rev);
+	$newtree{''} = {};
+
+	foreach $entry (@all_entries) {
+		($curfile, $histfile, $rev) = split /\|/, $entry;
+		($vol, $path, $file) = File::Spec->splitpath($histfile);
+		insert_entry(\%newtree, $path, $file, $curfile, $rev);
+		while ($path ne File::Spec->rootdir() && $path ne '') {
+
+			# Insert any directories in path into hash
+			($vol, $path, $file) =
+			  File::Spec->splitpath(
+				File::Spec->catdir(File::Spec->splitdir($path)));
+			insert_entry(\%newtree, $path, $file . '/');
+		}
+	}
+
+	# Make / point to ''
+	$newtree{ File::Spec->rootdir() } = $newtree{''};
+	delete $newtree{''};
+
+	$tree_cache{$release} = \%newtree;
+}
+
+sub get_tree {
+	my ($self, $release) = @_;
+	
+	# Return entire tree as provided by 'bk rset'
+	# First, check if cache exists
+	
+	my $fileh = new IO::File;
+	
+	if (-r $self->cachename($release)) {
+		$fileh->open($self->cachename($release)) or die "Whoops, can't open cached version";
+	} else {
+		# This command provide 3 part output - the current filename, the historical filename & the revision
+		$fileh = $self->openbkcommand("bk rset -h -l$release 2>/dev/null |");
+		my $line_to_junk = <$fileh>;    # Remove the Changelist|Changelist line at start
+		# Now create the cached copy if we can
+		if(open(CACHE, ">", $self->cachename($release))) {
+			$diskcachecount++;
+			my @data = <$fileh>;
+			close $fileh;
+			print CACHE @data;
+			close CACHE;
+			$fileh = new IO::File;
+			$fileh->open($self->cachename($release)) or die "Couldn't open cached version!";
+		}
+	}
+		
+	my @files = <$fileh>;
+	close $fileh;
+	chomp @files;
+
+	# remove any BitKeeper metadata except for deleted files
+	@files = grep (!(m!^BitKeeper! && !m!^BitKeeper/deleted/!), @files);
+
+	return @files;
+}
+
+sub cachename {
+	my ($self, $release) = @_;
+	return $self->{'cache'}."/treecache-".$release;
+}
+ 
+sub canonise {
+	my $path = shift;
+	$path =~ s!^/!!;
+	return $path;
+}
+
+# Check that the specified pathname, version combination exists in repository
+sub file_exists {
+	my ($self, $pathname, $release) = @_;
+
+	# Look the file up in the treecache
+	return defined($self->getfileinfo($pathname, $release));
+}
+
+sub getfileinfo {
+	my ($self, $pathname, $release) = @_;
+	$self->fill_cache($release);    # Normally expect this to be present anyway
+	$pathname = canonise($pathname);
+
+	my ($vol, $path, $file) = File::Spec->splitpath($pathname);
+	$path = File::Spec->rootdir() if $path eq '';
+
+	return $tree_cache{$release}{$path}{$file};
+}
+
+1;
\ No newline at end of file
diff -urN -x CVS -x .cvsignore lxr-0.9.4/lib/LXR/Files/Plain.pm lxr/lib/LXR/Files/Plain.pm
--- lxr-0.9.4/lib/LXR/Files/Plain.pm	2004-07-21 22:44:31.000000000 +0200
+++ lxr/lib/LXR/Files/Plain.pm	2005-11-03 00:39:55.000000000 +0100
@@ -1,6 +1,6 @@
 # -*- tab-width: 4 -*- ###############################################
 #
-# $Id$
+# $Id$
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -18,7 +18,7 @@
 
 package LXR::Files::Plain;
 
-$CVSID = '$Id$ ';
+$CVSID = '$Id$ ';
 
 use strict;
 use FileHandle;
@@ -100,6 +100,10 @@
 	my ($self, $pathname, $release) = @_;
 	my ($dir, $node, @dirs, @files);
 
+	if($pathname !~ m!/$!) {
+		$pathname = $pathname . '/';
+	}
+		
 	$dir = $self->toreal($pathname, $release);
 	opendir(DIR, $dir) || return ();
   FILE: while (defined($node = readdir(DIR))) {
@@ -164,14 +168,4 @@
 	return %index;
 }
 
-sub allreleases {
-	my ($self, $filename) = @_;
-
-	opendir(SRCDIR, $self->{'rootpath'});
-	my @dirs = readdir(SRCDIR);
-	closedir(SRCDIR);
-
-	return grep { /^[^\.]/ && -r $self->toreal($filename, $_) } @dirs;
-}
-
 1;
diff -urN -x CVS -x .cvsignore lxr-0.9.4/lib/LXR/Files.pm lxr/lib/LXR/Files.pm
--- lxr-0.9.4/lib/LXR/Files.pm	2004-07-21 22:44:30.000000000 +0200
+++ lxr/lib/LXR/Files.pm	2005-11-03 00:39:55.000000000 +0100
@@ -1,6 +1,6 @@
 # -*- tab-width: 4 -*- ###############################################
 #
-# $Id$
+# $Id$
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -18,23 +18,93 @@
 
 package LXR::Files;
 
-$CVSID = '$Id$ ';
+$CVSID = '$Id$ ';
 
 use strict;
 
 sub new {
-	my ($self, $srcroot) = @_;
+	my ( $self, $srcroot, $params ) = @_;
 	my $files;
 
-	if ($srcroot =~ /^CVS:(.*)/i) {
+	if ( $srcroot =~ /^CVS:(.*)/i ) {
 		require LXR::Files::CVS;
 		$srcroot = $1;
 		$files   = new LXR::Files::CVS($srcroot);
-	} else {
+	}
+	elsif ( $srcroot =~ /^bk:(.*)/i ) {
+		require LXR::Files::BK;
+		$srcroot = $1;
+		$files   = new LXR::Files::BK($srcroot, $params);
+	}
+	else {
 		require LXR::Files::Plain;
 		$files = new LXR::Files::Plain($srcroot);
 	}
 	return $files;
 }
 
+# Stub implementations of the Files interface
+
+sub getdir {
+	my $self = shift;
+	warn  "::getdir not implemented. Parameters @_";
+}
+
+sub getfile {
+	my $self = shift;
+	warn  "::getfile not implemented. Parameters @_";
+}
+
+sub getannotations {
+	my $self = shift;
+	warn  "::getannotations not implemented. Parameters @_";
+}
+
+sub getauthor {
+	my $self = shift;
+	warn  "::getauthor not implemented. Parameters @_";
+}
+
+sub filerev {
+	my $self = shift;
+	warn  "::filerev not implemented. Parameters @_";
+}
+
+sub getfilehandle {
+	my $self = shift;
+	warn  "::getfilehandle not implemented. Parameters @_";
+}
+
+sub getfilesize {
+	my $self = shift;
+	warn  "::getfilesize not implemented. Parameters @_";
+}
+
+sub getfiletime {
+	my $self = shift;
+	warn  "::getfiletime not implemented. Parameters @_";
+}
+
+sub getindex {
+	my $self = shift;
+	warn  "::getindex not implemented. Parameters @_";
+}
+
+sub isdir {
+	my $self = shift;
+	warn  "::isdir not implemented. Parameters: @_";
+}
+
+sub isfile {
+	my $self = shift;
+	warn  "::isfile not implemented. Parameters: @_";
+}
+
+sub toreal {
+	# FIXME: this function should probably not exist, since it doesn't make sense for 
+	# all file access methods
+	warn "toreal called - obsolete";
+	return undef;
+}
+
 1;
diff -urN -x CVS -x .cvsignore lxr-0.9.4/search lxr/search
--- lxr-0.9.4/search	2004-10-18 22:22:57.000000000 +0200
+++ lxr/search	2005-10-07 23:38:06.000000000 +0200
@@ -1,5 +1,5 @@
 #!/usr/bin/perl -T
-# $Id$
+# $Id$
 
 # search --	Freetext search
 #
@@ -23,7 +23,7 @@
 
 ######################################################################
 
-$CVSID = '$Id$ ';
+$CVSID = '$Id$ ';
 
 use strict;
 use lib '.'; # for Local.pm
@@ -162,7 +162,7 @@
 	if ($retval == 0) {
 		my $numlines = 0;
 		foreach my $hit (@result) {
-			print $hit, "<br>\n" if $hit =~ $hit =~ /No such file or directory/;	# feeble attempt to print possible errors (e.g. incomplete LD_LIBRARY_PATH causes linking errors)
+			print $hit, "<br>\n" if $hit =~ /No such file or directory/;	# feeble attempt to print possible errors (e.g. incomplete LD_LIBRARY_PATH causes linking errors)
 			next if $hit =~ /^err:/;    # skip; only 'no results' errors happen with return value 0
 
 			my ($score, $file) = $hit =~ /^(\d+) \/(.+) "(.+)" \d+/;
diff -urN -x CVS -x .cvsignore lxr-0.9.4/source lxr/source
--- lxr-0.9.4/source	2004-09-02 17:26:42.000000000 +0200
+++ lxr/source	2005-11-03 00:39:55.000000000 +0100
@@ -1,5 +1,5 @@
 #!/usr/bin/perl -T
-# $Id$
+# $Id$
 
 # source --	Present sourcecode as html, complete with references
 #  the '/icons' images are available in any standard Apache installation
@@ -24,11 +24,11 @@
 
 ######################################################################
 
-$CVSID = '$Id$ ';
+$CVSID = '$Id$ ';
 
 use strict;
-use lib '.'; # for Local.pm
-use lib do { $0 =~ m{(.*)/} ? "$1/lib" : "lib" }; # if LXR modules are in ./lib
+use lib '.';    # for Local.pm
+use lib do { $0 =~ m{(.*)/} ? "$1/lib" : "lib" };  # if LXR modules are in ./lib
 
 use LXR::Common qw(:html);
 use Local;
@@ -43,8 +43,9 @@
 		$img = "/icons/folder.gif";
 	}
 
-	return fileref("<img align=\"bottom\" border=\"0\" src=\"$img\" alt=\"folder\">", "",
-		$dir . $node);
+	return fileref(
+		"<img align=\"bottom\" border=\"0\" src=\"$img\" alt=\"folder\">",
+		"", $dir . $node);
 }
 
 sub dirname {
@@ -76,7 +77,8 @@
 	} else {
 		$img = "/icons/generic.gif";
 	}
-	return fileref("<img align=\"bottom\" border=\"0\" src=\"$img\" alt=\"\">", "", $dir . $node);
+	return fileref("<img align=\"bottom\" border=\"0\" src=\"$img\" alt=\"\">",
+		"", $dir . $node);
 }
 
 sub filename {
@@ -121,8 +123,11 @@
 
 	my @t = gmtime($file_time);
 	my ($sec, $min, $hour, $mday, $mon, $year) = @t;
-	return
-	  sprintf("%04d-%02d-%02d %02d:%02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min, $sec);
+	return sprintf(
+		"%04d-%02d-%02d %02d:%02d:%02d",
+		$year + 1900,
+		$mon + 1, $mday, $hour, $min, $sec
+	);
 }
 
 sub bgcolor {
@@ -145,8 +150,7 @@
 
 	@nodes = $files->getdir($dir, $release);
 	unless (@nodes) {
-		print(  "<p align=\"center\">\n<i>The directory "
-			  . $files->toreal($dir, $release)
+		print(  "<p align=\"center\">\n<i>The directory " . $dir
 			  . " does not exist.</i>\n");
 		print(
 			"\<p align=\"center\">\n<i>This directory might exist in other versions, try 'Show attic files' or select a different Version.</i>\n"
@@ -154,12 +158,6 @@
 		  if $files->isa("LXR::Files::CVS")
 		  and !$HTTP->{'param'}->{'showattic'};
 
-		#FIXME what does this do?
-		if ($files->toreal($dir, $release) =~ m#(.+[^/])[/]*$#) {
-			if (-e $1) {
-				warning("Unable to open " . $files->toreal($dir, $release));
-			}
-		}
 		return;
 	}
 
@@ -175,9 +173,10 @@
 					'namelink' => sub { dirname(@_, $node, $dir) },
 					'filesize' => sub { '-' },
 					'modtime'  => sub { modtime(@_, $node, $dir) },
-					'bgcolor' => sub { bgcolor(@_,  $line++) },
-					'css'     => sub { rowclass(@_, $line++) },
-					'description' => sub { descexpand(@_, $node, $dir, $release) }
+					'bgcolor'     => sub { bgcolor(@_,  $line++) },
+					'css'         => sub { rowclass(@_, $line++) },
+					'description' =>
+					  sub { descexpand(@_, $node, $dir, $release) }
 				)
 			);
 		} else {
@@ -193,7 +192,9 @@
 					'css'         => sub { rowclass(@_, $line++) },
 					'description' => sub {
 						(
-							$files->toreal($dir . $node, $release) =~ m|/Attic/|
+							$files->isa('LXR::Files::CVS')
+							  && $files->toreal($dir . $node, $release) =~
+							  m|/Attic/|
 							? "<i>In Attic</i>  "
 							: ""
 						  )
@@ -269,7 +270,9 @@
 						}
 
 						$b = $a;
-						$a .= ' ' x (6 - length($a)) . $files->getauthor($pathname, $a);
+						$a .=
+						  ' ' x (6 - length($a))
+						  . $files->getauthor($pathname, $a);
 						$a .= ' ' x (16 - length($a));
 					}
 				}
@@ -286,15 +289,14 @@
 			}
 
 		} else {
-			print("\<p align=\"center\">\n<i>The file $pathname does not exist.</i>\n");
+			print(
+				"\<p align=\"center\">\n<i>The file $pathname does not exist.</i>\n"
+			);
 			print(
 				"\<p align=\"center\">\n<i>This file might exist in other versions, try 'Show attic files' or select a different Version.</i>\n"
 			  )
 			  if $files->isa("LXR::Files::CVS")
 			  and !$HTTP->{'param'}->{'showattic'};
-			if (-f $files->toreal($pathname, $release)) {
-				warning("Unable to open " . $files->toreal($pathname, $release));
-			}
 		}
 	}
 }
diff -urN -x CVS -x .cvsignore lxr-0.9.4/templates/lxr.conf lxr/templates/lxr.conf
--- lxr-0.9.4/templates/lxr.conf	2005-04-30 23:30:07.000000000 +0200
+++ lxr/templates/lxr.conf	2005-11-03 00:39:55.000000000 +0100
@@ -108,8 +108,17 @@
 		# server access does NOT work.
 		#     'sourceroot'	=> 'cvs:/hom/karsk/a/CVSROOT/linux',
 
+		# For a BitKeeper repository, specify bk: followed by the path to the 
+		# repository.  For BK it is also necessary to specify a 'cachepath' parameter in
+		# the 'sourceparams' value below.  This should point to a directory where the 
+		# code can write and read files.
+		#     'sourceroot' => 'bk:/some/repository/here',
+		
 		# The name to display for this source tree
 		'sourcerootname' => 'Example',
+		
+		# Any parameters to the source access method should be specified below
+		'sourceparams' => {'cachepath' => '/a/path/here'},
 
 		# The DBI identifier for the database to use
 		# For mysql, the format is dbi:mysql:dbname=<name>
diff -urN -x CVS -x .cvsignore lxr-0.9.4/tests/AllTests.pm lxr/tests/AllTests.pm
--- lxr-0.9.4/tests/AllTests.pm	2005-05-05 01:21:09.000000000 +0200
+++ lxr/tests/AllTests.pm	2005-11-03 00:39:55.000000000 +0100
@@ -16,7 +16,8 @@
 	$suite->add_test(Test::Unit::TestSuite->new("ConfigTest"));
 	$suite->add_test(Test::Unit::TestSuite->new("SecurityTest"));
 	$suite->add_test(Test::Unit::TestSuite->new("CVSTest"));
-
+	$suite->add_test(Test::Unit::TestSuite->new("PlainTest"));
+#	$suite->add_test(Test::Unit::TestSuite->new("BKTest"));
 	return $suite;
 }
 
diff -urN -x CVS -x .cvsignore lxr-0.9.4/tests/BKTest.pm lxr/tests/BKTest.pm
--- lxr-0.9.4/tests/BKTest.pm	1970-01-01 01:00:00.000000000 +0100
+++ lxr/tests/BKTest.pm	2005-11-03 00:39:55.000000000 +0100
@@ -0,0 +1,479 @@
+# Test cases for the LXR::Files::BK module
+# Uses the associated lxr.conf file
+
+package BKTest;
+use strict;
+
+use Test::Unit;
+use Cwd;
+use Time::Local;
+use lib "..";
+use lib "../lib";
+
+use LXR::Files;
+
+use base qw(Test::Unit::TestCase);
+
+use vars qw($bkpath $bkrefdir $bkcache	);
+
+$bkpath   = getcwd() . "/bk-test-repository";
+$bkrefdir = getcwd() . "/bk-reference-files/";
+$bkcache  = getcwd() . "/bk-cache-dir";
+
+sub new {
+	my $self = shift()->SUPER::new(@_);
+
+	#	$self->{config} = {};
+	return $self;
+}
+
+# define tests
+
+# test that a bk files object can be created
+sub test_creation {
+	my $self = shift;
+	$self->assert(defined($self->{'bk'}), "Failed to create Files::BK");
+	$self->assert($self->{'bk'}->isa("LXR::Files::BK"), "Not a BK object");
+	$self->assert($self->{'bk'}->{'cache'} eq $bkcache);
+}
+
+# Access some of the values to check what is found
+sub test_root {
+	my $self = shift;
+	$self->assert(
+		$self->{'bk'}->{rootpath} eq $self->{'config'}->{'dir'},
+		"rootpath failed $self->{bk}->{rootpath} $self->{'config'}->{'dir'}"
+	);
+}
+
+# Test the getdir function
+
+package LXR::Files::BK::Test;
+use LXR::Files::BK;
+
+use vars qw(@ISA);
+
+@ISA = ("LXR::Files::BK");
+
+sub new {
+	my ($proto, $rootpath) = @_;
+	my $class = ref($proto) || $proto;
+	my $self  = $class->SUPER::new($rootpath, {'cachepath' => ''});
+
+	bless($self, $class);
+	return $self;
+}
+
+sub set_tree {
+	my ($self) = shift;
+	$self->{tree} = \@_;
+}
+
+sub get_tree {
+	my ($self) = shift;
+	return @{ $self->{'tree'} };
+}
+
+1;
+
+package BKTest;
+
+# Test the tree building & caching for the getdir function.
+#  Uses the BK::Test module to stub out real BK commands
+#  so entire operation carried out on virtual trees
+
+sub test_getdir_part1 {
+	my $self = shift;
+	my $bk   = new LXR::Files::BK::Test("/");
+	$bk->set_tree("README|README|1.1", "src/file1|src/file1|1.1",
+		"src/file2|src/file2|1.1",
+		"src/tests/newtest/test1|src/tests/newtest/test1|1.3");
+
+	my @files =
+	  sort($bk->getdir("/", 'test1'));  # use different releases to disambiguate
+	$self->assert_deep_equals(\@files, [ sort "README", "src/" ]);
+	@files = sort ($bk->getdir("", 'test1'));  # Check that interprets "" as "/"
+	$self->assert_deep_equals(\@files, [ sort "README", "src/" ]);
+	@files = sort($bk->getdir("src/", 'test1'));
+	$self->assert_deep_equals(\@files, [ sort "file1", "file2", "tests/" ]);
+	@files = sort($bk->getdir("src/tests/newtest/", 'test1'));
+	$self->assert_deep_equals(\@files, [ sort "test1" ]);
+	@files = sort($bk->getdir("src/tests/", 'test1'));
+	$self->assert_deep_equals(\@files, [ sort "newtest/" ]);
+	@files = sort($bk->getdir("src/tests/newtest/", 'test1'));
+	$self->assert_deep_equals(\@files, [ sort "test1" ]);
+
+	$bk->set_tree(
+		"BitKeeper/deleted/.del-README-34243232432|README|1.2",
+		"src/file1|src/file1|1.2",
+		"src/file2|src/file2|1.2",
+		"src/tests/newtest/test1|src/tests/newtest/test1|1.2",
+		"src/tests/newtest/test2|src/tests/newtest/test2|1.2",
+		"Config|Config|1.2"
+	);
+	@files =
+	  sort($bk->getdir("src/tests/newtest/", 'test1')); # Check cache is working
+	$self->assert_deep_equals(\@files, ["test1"]);
+	@files =
+	  sort($bk->getdir("src/tests/newtest/", 'test2'))
+	  ;    # Should pick up new entry
+	$self->assert_deep_equals(\@files, [ "test1", "test2" ]);
+	@files =
+	  sort($bk->getdir("src/tests/", 'test2'))
+	  ;    # Should still only see one copy of dir
+	$self->assert_deep_equals(\@files, ["newtest/"]);
+	@files =
+	  sort($bk->getdir("src/tests/newtest/", 'test1'))
+	  ;    # Check cache is still ok
+	$self->assert_deep_equals(\@files, ["test1"]);
+
+	# Now tests with invalid paths on entry
+	@files = sort($bk->getdir("src/tests", 'test2'));
+	$self->assert($#files == -1);
+}
+
+# Test the get_tree function and ensure it is giving the right answers
+sub test_get_tree {
+	my $self = shift;
+	my $bk   = $self->{'bk'};
+
+	my @versions = (1.5, 1.7, 1.6, 1.8);
+	foreach (@versions) {
+		my @tree = sort $bk->get_tree('@' . $_);
+		open(X, "${bkrefdir}bk-file-tree-$_")
+		  || die "Can't read ${bkrefdir}bk-file-tree-$_";
+		my @answer = sort <X>;
+		close X;
+		chomp @answer;
+		$self->assert_deep_equals(\@tree, \@answer, "Failed for version $_");
+	}
+}
+
+# Now test the getdir function with the full tree
+sub test_getdir_part2 {
+	my $self = shift;
+	my $bk   = $self->{'bk'};
+
+	# A revision with no deletions
+	my @entries = sort $bk->getdir('/firstdir/', '@1.3');
+	$self->assert(scalar(@entries) == 2, "entries is $#entries");
+	$self->assert_deep_equals(\@entries, [ sort ("file2", "file3") ]);
+	@entries = sort($bk->getdir('/seconddir/', '@1.6'));
+	$self->assert_deep_equals(\@entries, [ sort ("file4", "thirddir/") ]);
+
+	# Check the full recursive tree
+	@entries = sort $bk->getdir('/', '@1.11');
+	$self->assert_deep_equals(\@entries, [sort ("file1", "firstdir/", "seconddir/", "sourcedir/")]);
+	@entries = sort $bk->getdir('/sourcedir/', '@1.11');
+	$self->assert_deep_equals(\@entries, [sort ("cobol.c", "main.c", "subdir1/")]);
+	
+	# Now a revision after some files have been deleted
+	@entries = sort $bk->getdir('firstdir/', '@1.6');
+	$self->assert(scalar(@entries) == 0);
+	@entries = sort $bk->getdir('seconddir/', '@1.6');
+	$self->assert_deep_equals(\@entries, [ sort ('thirddir/', 'file4') ]);
+	@entries = sort $bk->getdir('seconddir/thirddir/', '@1.6');
+	$self->assert_deep_equals(\@entries, [ sort ('file5') ]);
+
+	# Now after a file in firstdir has been recreated
+	@entries = sort $bk->getdir('firstdir/', '@1.8');
+	$self->assert_deep_equals(\@entries, [ sort ('file2') ]);
+}
+
+# test getdir() ordering - dirs before files, all alphabetical
+sub test_getdir_part3 {
+	my $self = shift;
+	my $bk   = $self->{'bk'};
+
+	my @nodes = $bk->getdir('/', '@1.13');
+	$self->assert($nodes[0] =~ m!/$!);
+	my @expected = ('firstdir/', 'seconddir/', 'sourcedir/', 'file1');
+	$self->assert_deep_equals(\@nodes, \@expected);
+}
+
+# Test the cache of bitkeeper trees
+
+sub test_cache_creation {
+	my $self = shift;
+	my $bk   = $self->{'bk'};
+
+	# First nuke the cache directory & the memory cache
+	$self->clear_disk_cache();
+	
+	# Now ask for a specific tree
+	$bk->getdir('/', '@1.10');
+	$self->assert(-r $bk->cachename('@1.10'));
+	$bk->getdir('/sourcedir', '@1.3');
+	$self->assert(-r $bk->cachename('@1.3'));
+	
+	$self->clear_disk_cache();
+}	
+
+# Test the disk cache usage
+
+sub test_cache_usage {
+	my $self = shift;
+	my $bk = $self->{'bk'};
+	
+	# Test strategy is to clear the cache, create a cache file for a version
+	# that is known not to exist, then check that the info from that cached
+	# version is returned.
+	# First nuke the cache directory & the memory cache
+	$self->clear_disk_cache();
+
+	# Create the new information
+	open(X, ">", $bk->cachename('testversion')) or die "Can't create test cache entry";
+	print X "foobar|foobar|1.1\n";
+	print X "another|another|1.2\n";
+	print X "somewhere/other|somewhere/new|1.3\n";
+	close X;
+	
+	my @entries = sort $bk->getdir('/', 'testversion');
+	$self->assert_deep_equals(\@entries, [sort ("foobar", "another", "somewhere/")]);
+	
+	$self->clear_disk_cache();
+}
+
+sub clear_disk_cache {
+	my $self = shift;
+	
+	system('rm -rf '.$bkcache);
+	$self->assert(!-d $bkcache);	
+	system('mkdir '.$bkcache);
+	$self->assert(-d $bkcache);
+	%LXR::Files::BK::tree_cache = ('' => '');
+}
+
+# Tests for the cache manipulation commands
+sub test_fileexists {
+	my $self = shift;
+	my $bk   = $self->{'bk'};
+
+	# These all exist
+	$self->assert($bk->file_exists('/file1',                    '@1.2'));
+	$self->assert($bk->file_exists('/file1',                    '@1.6'));
+	$self->assert($bk->file_exists('/file1',                    '@1.8'));
+	$self->assert($bk->file_exists('/firstdir/file2',           '@1.3'));
+	$self->assert($bk->file_exists('/firstdir/file3',           '@1.5'));
+	$self->assert($bk->file_exists('/seconddir/thirddir/file5', '@1.6'));
+
+	# And these don't
+	$self->assert(!$bk->file_exists('/file1',                    '@1.1'));
+	$self->assert(!$bk->file_exists('/file2',                    '@1.3'));
+	$self->assert(!$bk->file_exists('/firstdir/',                '@1.8'));
+	$self->assert(!$bk->file_exists('/firstdir/file2',           '@1.2'));
+	$self->assert(!$bk->file_exists('/firstdir/file3',           '@1.6'));
+	$self->assert(!$bk->file_exists('/seconddir/thirddir/file4', '@1.6'));
+}
+
+sub test_getfileinfo {
+	my $self = shift;
+	my $bk   = $self->{'bk'};
+
+	# These all exist
+	$self->assert(defined($bk->getfileinfo('/file1', '@1.2')));
+	$self->assert($bk->getfileinfo('/file1', '@1.6')->{'revision'} == 1.1);
+	$self->assert($bk->getfileinfo('/file1', '@1.8')->{'curpath'} eq 'file1');
+	my $info = $bk->getfileinfo('/firstdir/file2', '@1.3');
+	$self->assert($info->{'revision'} == 1.1);
+	$self->assert(
+		$info->{'curpath'} eq 'BitKeeper/deleted/.del-file2~7a40a14b3cb5ac42');
+
+	# And these don't
+	$self->assert(!defined($bk->getfileinfo('/file1', '@1.1')));
+	$self->assert(!defined($bk->getfileinfo('/file2', '@1.3')));
+}
+
+# Some basic getfile tests
+# Check for correct & incorrect pathnames and versions
+sub test_getfile {
+	my $self = shift;
+	my $bk   = $self->{'bk'};
+
+	my $data = $bk->getfile("/firstdir/file2", '@1.3');
+	open(FILE, '<', $bkrefdir . 'firstdir^file2^@1.3')
+	  || die "Can't open file to check contents firstdir^file2^\@1.3";
+	local ($/) = undef;
+	my $check = <FILE>;
+	close FILE;
+	$self->assert($check eq $data, "File read didn't match");
+
+# Pathnames must start with a "/" for CVS/Plain but we'll accept without - for now!
+	$data = $bk->getfile("firstdir/file2", '@1.3');
+	$self->assert($check eq $data, "File read didn't match");
+	$data = $bk->getfile("/an/impossible/path/that/doesn/t/exist", '@131');
+	$self->assert(!defined($data));
+	$data = '';
+	$data = $bk->getfile("include/linux/jffs.h", '@1345');
+	$self->assert(!defined($data));
+}
+
+# Detailed getfile tests
+# Checking here that we can correctly recover:
+#  - the same file at two different revisions
+#  - a file that has been deleted
+#  - a file that has been deleted and then reconstructed
+#      (i.e. the new dir/file is different to dir/file at a previous revision
+#  - a file that has been moved
+sub test_getfile2 {
+	my $self = shift;
+	my $bk   = $self->{'bk'};
+
+	# These are all valid versions with contents
+	my @versions = (
+		'/seconddir/file4',          '@1.4',     # rev 1
+		'/seconddir/file4',          '@1.7',     # rev 2
+		'/firstdir/file2',           '@1.4',     # before delete
+		'/firstdir/file2',           '@1.8',     # after reconstruction
+		'/seconddir/thirddir/file5', '@1.6',     # before move
+		'/seconddir/thirddir/file6', '@1.9',     # after move
+		'/seconddir/file7',          '@1.10',    # after move to new dir
+	);
+
+	while (scalar(@versions)) {
+		my $file      = shift @versions;
+		my $ver       = shift @versions;
+		my $data      = $bk->getfile($file, $ver);
+		my $checkfile = substr($file, 1);
+		$checkfile =~ s{/}{^}g;
+		$checkfile = $bkrefdir . $checkfile . '^' . $ver;
+		open(X, '<', $checkfile) or die "Can't open file $checkfile";
+		local ($/) = undef;
+		my $check = <X>;
+		close X;
+		$self->assert_equals($data, $check, "Failed for $file, $ver");
+	}
+}
+
+sub test_getfilehandle {
+	my ($self) = shift;
+	my $bk = $self->{'bk'};
+
+	$self->assert(defined($bk->getfilehandle("/firstdir/file2",  '@1.3')));
+	$self->assert(defined($bk->getfilehandle("/seconddir/file4", '@1.6')));
+	$self->assert(defined($bk->getfilehandle('file1',            '@1.2')));
+	$self->assert(
+		!defined($bk->getfilehandle("/random/path/to/nowhere", '@1.1449')));
+	$self->assert(!defined($bk->getfilehandle("/file1",          '1.1')));
+	$self->assert(!defined($bk->getfilehandle("/firstdir/file3", '@1.8')));
+	$self->assert(!defined($bk->getfilehandle("/seconddir/file7", '@1.8')));
+	$self->assert(!defined($bk->getfilehandle("/seconddir/thirddir/file5", '@1.10')));
+}
+
+# Test filerev
+#  Need to ensure that the filerevs are < 255 chars & sensible!
+#  Oh, and they change when the file changes!
+sub test_filerev {
+	my ($self) = shift;
+	my $bk = $self->{'bk'};
+	
+	# A file that has changed contents
+	my $rev = $bk->filerev('/file1', '@1.3');
+	$self->assert($rev);
+	$self->assert_not_equals($rev, $bk->filerev('/file1', '@1.12'));
+	
+	# A file that hasn't changed
+	$rev = $bk->filerev('/firstdir/file2', '@1.3');
+	$self->assert_equals($rev, $bk->filerev('/firstdir/file2', '@1.5'));
+	$self->assert(length($rev) < 255);
+	
+	# A file that has been deleted & recreated
+	$rev = $bk->filerev('/firstdir/file2', '@1.5');
+	$self->assert_not_equals($rev, $bk->filerev('/firstdir/file2', '@1.9'));
+}
+
+# Test isdir
+#  Assuming that pathname will always end in / if it's a dir
+#  - this may not be correct!
+sub test_isdir {
+	my ($self) = shift;
+	my $bk = $self->{'bk'};
+	
+	$self->assert($bk->isdir('/firstdir/', '@1.3'));
+	$self->assert($bk->isdir('/seconddir/thirddir/','@1.6'));
+	$self->assert(!$bk->isdir('/not/a/dir/', '@1.3'));
+	$self->assert(!$bk->isdir('/seconddir/file2/', '@1.4'));
+	$self->assert(!$bk->isdir('/file1','@1.11'));
+	$self->assert(!$bk->isdir('/sourcedir/main.c', '@1.12'));
+	$self->assert(!$bk->isdir('/sourcedir/', '@1.10')); 
+}
+
+sub test_isfile {
+	my ($self) = shift;
+	my $bk = $self->{'bk'};
+	
+	$self->assert($bk->isfile('/file1', '@1.12'));
+	$self->assert($bk->isfile('/sourcedir/main.c', '@1.12'));
+	$self->assert(!$bk->isfile('/sourcedir/main.c', '@1.9'));
+	$self->assert(!$bk->isfile('/seconddir/thirddir/', '@1.9'));
+}
+
+# Test the getfiletime function
+#  tests are assuming that undef is OK for a directory
+sub test_getfiletime {
+	my ($self) = shift;
+	my $bk = $self->{'bk'};
+	
+	$self->assert_equals($bk->getfiletime('/file1', '@1.3'), timegm(30,20,14,13,01,2005)); # Note months is 0..11
+	$self->assert_equals($bk->getfiletime('/file1', '@1.3'), $bk->getfiletime('file1', '@1.11'));
+	$self->assert(!defined($bk->getfiletime('/sourcedir/', '@1.12')));
+}
+
+# Test the getfilesize
+sub test_getfilesize {
+	my ($self) = shift;
+	my $bk = $self->{'bk'};
+	
+	$self->assert_equals($bk->getfilesize('/file1', '@1.3'), 60);
+	$self->assert_equals($bk->getfilesize('/file1', '@1.3'), $bk->getfilesize('file1', '@1.11'));
+	$self->assert(!defined($bk->getfilesize('/sourcedir/main.c', '@1.9')));
+}
+
+# Test getauthor
+
+sub test_getauthor {
+	my ($self) = shift;
+	my $bk = $self->{'bk'};
+
+	$self->assert_equals('malcolm', $bk->getauthor('/file1', '@1.3'));
+	$self->assert_equals('malcolm', $bk->getauthor('/sourcedir/cobol.c', '@1.13'));
+	$self->assert_null($bk->getauthor('/sourcedir/cobol.c', '@1.3'));
+}
+
+# Test getannotations
+#  Only problem is that I don't have a clue what this function should return - so
+#  for now we're stubbing it out a la Plain.pm
+
+sub test_getannotations {
+	my ($self) = shift;
+	my $bk = $self->{'bk'};
+
+	$self->assert_deep_equals([], [ $bk->getannotations('/file1', '@1.3') ]);
+}
+
+# Tests of helper functions in BK.pm
+sub test_canonise {
+	my ($self) = shift;
+	my $bk = $self->{'bk'};
+	$self->assert(
+		LXR::Files::BK::canonise('/path/to/somewhere') eq 'path/to/somewhere');
+	$self->assert(LXR::Files::BK::canonise('/') eq '');
+}
+
+# set_up and tear_down are used to
+# prepare and release resources need for testing
+
+# Prepare a config object
+sub set_up {
+	my $self = shift;
+	$self->{'bk'} = new LXR::Files("bk:$bkpath", {'cachepath' => $bkcache});
+	$self->{'config'}->{'dir'} = "$bkpath";
+}
+
+sub tear_down {
+	my $self = shift;
+
+	#	$self->{config} = undef;
+}
+
+1;
diff -urN -x CVS -x .cvsignore lxr-0.9.4/tests/ConfigTest.pm lxr/tests/ConfigTest.pm
--- lxr-0.9.4/tests/ConfigTest.pm	2004-09-06 23:54:45.000000000 +0200
+++ lxr/tests/ConfigTest.pm	2005-11-03 00:39:55.000000000 +0100
@@ -49,9 +49,37 @@
 	my @vars = $self->{config}->allvariables();
     $self->assert(grep {$_ eq 'v'} @vars, "allvariables didn't return v");
 	$self->assert(grep {$_ eq 'a'} @vars, "allvariables didn't return a");
-	$self->assert($#vars == 1, "Too many variables returned got " . $self->{config}->allvariables());
+	$self->assert($#vars == 1, "Too many variables returned got @vars");
 }
 
+sub test_config_error {
+	my $self = shift;
+	my $t;
+	
+	eval {new LXR::Config("/a/path", "./lxr.conf")};
+	$t = $@;
+	$self->assert(defined($t), "Didn't fail to find config");
+	$self->assert_matches(qr/--url parameter should be a URL \(e\.g\. http:/, $t);
+}
+
+# Test access to the sourceparams section
+
+sub test_sourceparams {
+	my $self = shift;
+	my $config = $self->{'config'};
+	
+	my $params = $config->sourceparams;
+	$self->assert_equals($$params{'cachepath'}, '/a/path/to/cache');
+	$self->assert_equals($$params{'param2'}, 'secondparam');
+}
+
+# Test multiple config block with common substrings work
+# Bug 525825
+sub test_multi_config {
+	my $self = shift;
+	my $test = eval {new LXR::Config("http://test/lxr-wibble", "./lxr.conf");};
+	$self->assert(!defined($test), "Should not have matched");
+	}
 
 # set_up and tear_down are used to
 # prepare and release resources need for testing
diff -urN -x CVS -x .cvsignore lxr-0.9.4/tests/PlainTest.pm lxr/tests/PlainTest.pm
--- lxr-0.9.4/tests/PlainTest.pm	1970-01-01 01:00:00.000000000 +0100
+++ lxr/tests/PlainTest.pm	2005-11-03 00:39:55.000000000 +0100
@@ -0,0 +1,95 @@
+# Test cases for the LXR::Files::Plain module
+# Uses the associated lxr.conf file
+
+package PlainTest;
+use strict;
+
+use Test::Unit;
+use lib "..";
+use lib "../lib";
+
+use LXR::Files;
+use LXR::Config;
+use LXR::Common;
+
+use base qw(Test::Unit::TestCase);
+
+use vars qw($root);
+
+$root = "/Users/malcolmbox/dev/lxr-src/";
+
+$config = new LXR::Config("http://test/lxr", "./lxr.conf");
+
+sub new {
+	my $self = shift()->SUPER::new(@_);
+#	$self->{config} = {};
+	return $self;
+}
+
+# define tests
+
+# test that a files object can be created
+sub test_creation {
+	my $self = shift;
+	$self->assert(defined($self->{'plain'}), "Failed to create Files::Plain");
+	$self->assert($self->{'plain'}->isa("LXR::Files::Plain"), "Not a Plain object");
+}
+
+# Access some of the values to check what is found
+sub test_root {
+	my $self = shift;
+	$self->assert($self->{'plain'}->{rootpath} eq $self->{'config'}->{'dir'},
+		   "rootpath failed $self->{plain}->{rootpath} $self->{'config'}->{'dir'}");
+}
+
+# Test the get_dir function.  Depends on the ctags 5.5.4 release being in place
+
+sub test_getdir {
+	my $self = shift;
+	my $f = $self->{'plain'};
+	
+	my @files = sort($f->getdir("/",'5.5.4'));  # use different releases to disambiguate
+	my @files2 = sort($f->getdir("", '5.5.4')); # should now produce same result
+	$self->assert_deep_equals(\@files, \@files2);
+	
+	# Check for invalid behaviours
+	@files = $f->getdir("/COPYING", '5.5.4');
+	$self->assert($#files == -1);
+	@files = $f->getdir("tests", '5.5.4');
+	$self->assert($#files == -1);
+	@files = $f->getdir("notthere/", '5.5.4');
+	$self->assert($#files == -1);
+}
+
+# Test the get_file method.
+
+sub test_getfile {
+	my $self = shift;
+	my $f = $self->{'plain'};
+	
+	my $file = $f->getfile("/COPYING", '5.5.4');
+	local ($/) = undef;
+	open FILE, "<". "$root/5.5.4/COPYING" || die "Can't open file";
+	my $ref = <FILE>;
+	$self->assert($file eq $ref, "Files not matching");
+}
+
+# set_up and tear_down are used to
+# prepare and release resources need for testing
+
+# Prepare a config object
+ sub set_up {
+	my $self = shift;
+	$self->{'plain'} = new LXR::Files("$root");
+ 	$self->{'config'}->{'dir'} = "$root";
+ 	}
+
+ sub tear_down {
+	my $self = shift;
+#	$self->{config} = undef;
+ }
+
+
+
+
+1;
diff -urN -x CVS -x .cvsignore lxr-0.9.4/tests/SecurityTest.pm lxr/tests/SecurityTest.pm
--- lxr-0.9.4/tests/SecurityTest.pm	2005-05-06 00:01:34.000000000 +0200
+++ lxr/tests/SecurityTest.pm	2005-09-10 00:06:18.000000000 +0200
@@ -123,13 +123,12 @@
 	$SIG{'__DIE__'} = $die;
 	$SIG{'__WARN__'} = $warn;
 
-	$self->assert($pathname eq '/', "pathname not washed, got $pathname");
-	$self->assert($HTTP->{'param'}->{'file'} eq $pathname, '$http->{param}->{file} not washed, got '.$HTTP->{'param'}->{'file'});	
+	$self->assert($pathname eq '/a/test/path/', "pathname not washed, got $pathname");
 	
 	$ENV{'PATH_INFO'} = '';
 	$ENV{'QUERY_STRING'} = 'file=/a/test/path++many';
-	my $die = $SIG{'__DIE__'};
-	my $warn = $SIG{'__WARN__'};
+	$die = $SIG{'__DIE__'};
+	$warn = $SIG{'__WARN__'};
 	httpinit;
 	$SIG{'__DIE__'} = $die;
 	$SIG{'__WARN__'} = $warn;
@@ -137,15 +136,47 @@
 
 	$ENV{'PATH_INFO'} = '/../.././.././a/test/path+!/some/%chars,v';
 	$ENV{'QUERY_STRING'} = '';
-	my $die = $SIG{'__DIE__'};
-	my $warn = $SIG{'__WARN__'};
+	$die = $SIG{'__DIE__'};
+	$warn = $SIG{'__WARN__'};
 	httpinit;
 	$SIG{'__DIE__'} = $die;
 	$SIG{'__WARN__'} = $warn;
 	$self->assert($pathname eq '/a/test/path+!/some/%chars,v', "pathname not washed, got $pathname");
 	
+	$ENV{'PATH_INFO'} = '/ab/-/path+!/some/%chars,v';
+	$ENV{'QUERY_STRING'} = '';
+	$die = $SIG{'__DIE__'};
+	$warn = $SIG{'__WARN__'};
+	httpinit;
+	$SIG{'__DIE__'} = $die;
+	$SIG{'__WARN__'} = $warn;
+	$self->assert($pathname eq '/ab/-/path+!/some/%chars,v', "pathname not washed, got $pathname");
 }
 
+sub test_filename_compat {
+	# Checking for ability to deal with ++ in the filename
+	my $self = shift;
+
+	$ENV{'SERVER_NAME'} = 'test';
+	$ENV{'SERVER_PORT'} = 80;
+	$ENV{'SCRIPT_NAME'} = '/lxr/source';
+	$ENV{'PATH_INFO'} = '/a/test/file++name';
+	$ENV{'QUERY_STRING'} = '';
+
+	# Need to preserve signal handlers round call to httpinit as
+	# it sets up the LXR signal handlers.
+	
+	my $die = $SIG{'__DIE__'};
+	my $warn = $SIG{'__WARN__'};
+	
+	httpinit;
+	
+	$SIG{'__DIE__'} = $die;
+	$SIG{'__WARN__'} = $warn;
+
+	$self->assert($pathname eq '/a/test/file++name', "pathname corrupted, got $pathname");
+}
+	
 
 sub test_config {
 	# Check that parameters in URL cannot alter config variables
diff -urN -x CVS -x .cvsignore lxr-0.9.4/tests/lxr.conf lxr/tests/lxr.conf
--- lxr-0.9.4/tests/lxr.conf	2005-05-05 01:21:09.000000000 +0200
+++ lxr/tests/lxr.conf	2005-11-03 00:39:55.000000000 +0100
@@ -95,7 +95,7 @@
   # The name to display for this source tree
   'sourcerootname'	=> 'Example',
 
-
+  'sourceparams' => {'cachepath' => '/a/path/to/cache', 'param2' => 'secondparam'},
   # The DBI identifier for the database to use
   # For mysql, the format is dbi:mysql:dbname=<name>
   # for Postgres, it is dbi:Pg:dbname=<name>
@@ -177,7 +177,8 @@
 # 				 ['tcl', '(?i)\.tcl$|\.wish$'   #'
 # 				  , 'LXR::Lang::Generic'],
 				},
-
+				
+	'ignoredirs' => [],
   # Maps interpreter names to languages.  The format is:
   #  regexp => langname
   #   regexp is matched against the part after #! on the first line of a file
